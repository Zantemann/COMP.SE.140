events {}

http {
    upstream service1 {
        server service1:8199;
    }

    upstream api-gateway {
        server api-gateway:8198;
    }

    # Define a rate limit zone to allow one request to service1 every two seconds.
    # To allow all three instances to run simultaneously, the rate should be three times higher: "rate=90r/m".
    limit_req_zone $binary_remote_addr zone=one:10m rate=30r/m;
    lua_shared_dict user_sessions 10m;
    lua_shared_dict system_state 10m;
    
    # Set initial state to INIT
    init_by_lua_block {
        local state_store = ngx.shared.system_state
        state_store:set("state", "INIT")
    }
    
    server {
        listen 8197;

        # Use the Docker DNS resolver to resolve service names within the Docker network
        resolver 127.0.0.11 valid=5s;

        # Lua-based session handling
        access_by_lua_block {
            local session_store = ngx.shared.user_sessions
            local auth_header = ngx.var.http_authorization
            local state_store = ngx.shared.system_state
            local remote_addr = ngx.var.remote_addr

            -- Check if the system is in PAUSED state
            local current_state = state_store:get("state")
            if current_state == "PAUSED" and not (ngx.var.request_uri == "/state" and ngx.var.request_method == "PUT") then
                ngx.status = 503
                ngx.header.content_type = "text/plain"
                ngx.say("PAUSED")
                return ngx.exit(503)
            end

            if session_store:get(remote_addr) then
                -- Session exists, user is authorized
                return
            end

            if not auth_header then
                -- Allow GET requests to /state without authentication
                if ngx.var.request_uri == "/state" and ngx.var.request_method == "GET" then
                    return
                end

                -- No auth header
                ngx.status = ngx.HTTP_UNAUTHORIZED
                ngx.say("Authorization required")
                return ngx.exit(401)
            end

            ngx.exec("@auth_basic_check")
        }

        location @auth_basic_check {
            # Check authentication credentials from .htpasswd
            auth_basic "Restricted Access";
            auth_basic_user_file /etc/nginx/.htpasswd;

            access_by_lua_block {
                -- If auth_basic succeeds, save the session
                local session_store = ngx.shared.user_sessions
                local remote_addr = ngx.var.remote_addr
                local state_store = ngx.shared.system_state

                if not session_store:get(remote_addr) then
                    session_store:set(remote_addr, true, 3600) -- Save session for 1 hour

                    -- Read the request body
                    ngx.req.read_body()

                    -- Make the internal PUT request with the body
                    local res = ngx.location.capture("/state", {
                        method = ngx.HTTP_PUT,
                        body = "RUNNING",
                        headers = {
                            ["Content-Type"] = "text/plain"
                        }
                    })

                    if res.status == ngx.HTTP_OK then
                        state_store:set("state", "RUNNING")
                        ngx.header.content_type = "text/plain"
                        ngx.say("RUNNING")
                        return ngx.exit(ngx.HTTP_OK)                      
                    end

                    
                end
            }
        }

        location / {
            root /usr/share/nginx/html;
            index index.html;
        }

        location /stop {
            # Apply rate limiting globally across all instances.
            # To allow running 3 instances simultaneously, "burst=3" should be included.
            limit_req zone=one nodelay;

            proxy_pass http://service1/stop;
        }

        location /state {
            limit_req zone=one nodelay;

            access_by_lua_block {
                local state_store = ngx.shared.system_state
                local session_store = ngx.shared.user_sessions
                local auth_header = ngx.var.http_authorization
                local remote_addr = ngx.var.remote_addr

                -- Enforce authentication check for access_by_lua_block
                if not session_store:get(remote_addr) and ngx.var.request_method == "PUT" then
                    if not auth_header then
                        ngx.status = ngx.HTTP_UNAUTHORIZED
                        ngx.header.content_type = "text/plain"
                        ngx.say("Authorization required")
                        return ngx.exit(ngx.HTTP_UNAUTHORIZED)
                    end

                    ngx.exec("@auth_basic_check")
                    return
                end

                if ngx.var.request_method == "PUT" then
                    -- Read the request body
                    ngx.req.read_body()
                    local new_state = ngx.req.get_body_data()

                    -- Validate the new state
                    if new_state == "INIT" or new_state == "PAUSED" or new_state == "RUNNING" or new_state == "SHUTDOWN" then
                        -- Store the new state
                        state_store:set("state", new_state)

                        -- Clear the session if the state is INIT
                        if new_state == "INIT" then
                            local remote_addr = ngx.var.remote_addr
                            session_store:delete(remote_addr)
                            ngx.log(ngx.ERR, "Session cleared for: ", remote_addr)
                        end

                        -- Make an internal request to /stop if the state is SHUTDOWN
                        if new_state == "SHUTDOWN" then
                            local res = ngx.location.capture("/stop", { method = ngx.HTTP_POST })
                            if res.status ~= ngx.HTTP_OK then
                                ngx.log(ngx.ERR, "Failed to call /stop: ", res.body)
                                return ngx.exit(res.status)
                            end
                        end
                    else
                        ngx.header.content_type = "text/plain"
                        ngx.say("Invalid state: ", new_state)
                        return ngx.exit(ngx.HTTP_BAD_REQUEST)
                    end
                elseif ngx.var.request_method == "GET" then
                    -- Return the current state as plain text
                    local current_state = state_store:get("state")
                    ngx.header.content_type = "text/plain"
                    ngx.say(current_state)
                    ngx.log(ngx.ERR, "Current state: ", current_state)
                    return ngx.exit(ngx.HTTP_OK)
                end
            }

            # Write logs
            proxy_pass http://api-gateway/state;
        }

        location /request {
            limit_req zone=one nodelay;

            proxy_pass http://service1/api;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /run-log {
            limit_req zone=one nodelay;

            proxy_pass http://api-gateway/run-log;
        }
    }
}