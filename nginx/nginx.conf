events {}

http {
    upstream service1 {
        server service1:8199;
    }

    upstream api-gateway {
        server api-gateway:8198;
    }

    # Define a rate limit zone to allow one request to service1 every two seconds.
    # To allow all three instances to run simultaneously, the rate should be three times higher: "rate=90r/m".
    limit_req_zone $binary_remote_addr zone=one:10m rate=30r/m;
    lua_shared_dict user_sessions 10m;

    server {
        listen 8197;

        # Use the Docker DNS resolver to resolve service names within the Docker network
        resolver 127.0.0.11 valid=5s;

        # Lua-based session handling
        access_by_lua_block {
            local session_store = ngx.shared.user_sessions
            local auth_header = ngx.var.http_authorization

            if session_store:get(ngx.var.remote_addr) then
                -- Session exists, user is authorized
                return
            end

            if not auth_header then
                -- No auth header, request authentication
                ngx.status = 401
                ngx.say("Authorization required")
                return ngx.exit(401)
            end

            -- Auth header exists but not validated yet
            -- Allow Nginx to process basic auth and validate credentials
            ngx.exec("@auth_basic_check")
        }

        location @auth_basic_check {
            # Check authentication credentials from .htpasswd
            auth_basic "Restricted Access";
            auth_basic_user_file /etc/nginx/.htpasswd;

            access_by_lua_block {
                -- If auth_basic succeeds, save the session
                local session_store = ngx.shared.user_sessions
                session_store:set(ngx.var.remote_addr, true, 3600) -- Save session for 1 hour
            }
        }

        location / {
            root /usr/share/nginx/html;
            index index.html;
        }
        
        location /api {
            # Apply rate limiting globally across all instances.
            # To allow running 3 instances simultaneously, "burst=3" should be included.
            limit_req zone=one nodelay;

            proxy_pass http://service1/api;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /stop {
            limit_req zone=one nodelay;

            proxy_pass http://service1/stop;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /state {
            limit_req zone=one nodelay;

            proxy_pass http://api-gateway/state;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /request {
            limit_req zone=one nodelay;

            proxy_pass http://api-gateway/request;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /run-log {
            limit_req zone=one nodelay;

            proxy_pass http://api-gateway/run-log;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}